TITLE

; Name: Afsao Bin Masud
; Date: 28/11/2021
; ID: 104507333
; Description: Assignment 7

INCLUDE Irvine32.inc
INCLUDELIB Irvine32.lib

.data
	; data declarations go here
	prompt0 BYTE "0 create and array || 1 move array to stack || 2 move stack to array || 3 reverse array || -1 exit", 0
	prompt1 BYTE "What do you want to do now? > ", 0
	prompt2 BYTE "What is the size N off Array? (1 to 20) > ", 0
	prompt3 BYTE "What are the values in the Array? > ", 0
	prompt4 BYTE "Size off Array is N = ", 0
	prompt5 BYTE "Array = ", 0
	prompt6 BYTE "Stack is empty", 0
	prompt7 BYTE "Stack not empty", 0
	prompt8 BYTE "Array is ", 0
	prompt9 BYTE "Stack is ", 0
	prompt10 BYTE " before ArrayToStack", 0
	prompt11 BYTE " after ArrayToStack", 0
	prompt12 BYTE " before StackToArray", 0
	prompt13 BYTE " after StackToArray", 0
	prompt14 BYTE " before StackReverse", 0
	prompt15 BYTE " after StackReverse", 0
	space BYTE " ", 0
	error0 BYTE "Invalid entry, please try again!", 0
	
	array DWORD 20 DUP(?)

	choice DWORD ?
	aSize DWORD ?

.code
createArray PROC
	beginwhile:
		; Display prompt to create array size and get user input
		mov edx, OFFSET prompt2
		call WriteString
		call ReadInt
		call Crlf
		mov aSize, eax
		; Check user input for out of bound parameters
		cmp aSize, 20
		jg beginwhile
		cmp aSize, 1
		jl beginwhile
	endwhile:

	; Display prompt to get user input for array values
	mov edx, OFFSET prompt3
	call WriteString
	
	mov ecx, aSize
	mov eax, 0
	mov esi, 0
	
	L1:
		call ReadInt
		push eax
		add esi, 4
	loop L1
	
	mov ecx, aSize
	mov esi, 0

	L2:
		pop eax
		mov array[esi], eax
		add esi, 4
	loop L2
	
	mov ecx, aSize
	mov eax, 0
	mov esi, 0
	
	L3:
		mov eax, array[esi]
		push eax
		add esi, 4
	loop L3
	
	mov ecx, aSize
	mov esi, 0

	L4:
		pop eax
		mov array[esi], eax
		add esi, 4
	loop L4
	
	; Display user values
	call Crlf
	mov edx, OFFSET prompt4
	call WriteString
	mov eax, aSize
	call WriteDec
	call Crlf
	call Crlf
	mov edx, OFFSET prompt5
	call WriteString
	
	mov ecx, aSize
	mov esi, 0

	L5:
		mov eax, array[esi]
		add esi, 4
		call WriteDec
		mov edx, OFFSET space
		CALL WriteString
	loop L5

	call Crlf
	call Crlf
	mov edx, OFFSET prompt6
	call WriteString
	call Crlf
	call Crlf

	ret 
createArray ENDP

InvalidEntry PROC
	mov edx, OFFSET error0
	call WriteString
	call Crlf
	call Crlf
	ret
InvalidEntry ENDP

ArrayToStack PROC
	mov edx, OFFSET prompt8
	call WriteString
	mov edx, OFFSET space
	call WriteString
	
	mov ecx, aSize
	mov esi, 0

	d1:
		mov eax, array[esi]
		add esi, 4
		call WriteDec
		mov edx, OFFSET space
		CALL WriteString
	loop d1

	mov edx, OFFSET prompt10
	call WriteString
	call Crlf
	call Crlf

	mov ecx, aSize
	mov eax, 0
	mov esi, 0
	
	L1:
		mov eax, array[esi]
		push eax
		add esi, 4
	loop L1
	
	mov ecx, aSize
	mov esi, 0

	L2:
		pop eax
		mov array[esi], eax
		add esi, 4
	loop L2
	
	mov ecx, aSize
	mov esi, 0

	mov edx, OFFSET prompt9
	call WriteString
	mov edx, OFFSET space
	call WriteString
	
	d2:
		mov eax, array[esi]
		add esi, 4
		call WriteDec
		mov edx, OFFSET space
		CALL WriteString
	loop d2

	mov edx, OFFSET prompt11
	call WriteString
	call Crlf
	call Crlf

	mov edx, OFFSET prompt7
	call WriteString
	call Crlf
	call Crlf

	ret
ArrayToStack ENDP

StackToArray PROC
	mov edx, OFFSET prompt9
	call WriteString
	mov edx, OFFSET space
	call WriteString
	
	mov ecx, aSize
	mov esi, 0

	d1:
		mov eax, array[esi]
		add esi, 4
		call WriteDec
		mov edx, OFFSET space
		CALL WriteString
	loop d1

	mov edx, OFFSET prompt12
	call WriteString
	call Crlf
	call Crlf

	mov ecx, aSize
	mov eax, 0
	mov esi, 0
	
	L1:
		mov eax, array[esi]
		push eax
		add esi, 4
	loop L1
	
	mov ecx, aSize
	mov esi, 0

	L2:
		pop eax
		mov array[esi], eax
		add esi, 4
	loop L2
	
	mov ecx, aSize
	mov esi, 0

	mov edx, OFFSET prompt8
	call WriteString
	mov edx, OFFSET space
	call WriteString
	
	d2:
		mov eax, array[esi]
		add esi, 4
		call WriteDec
		mov edx, OFFSET space
		CALL WriteString
	loop d2

	mov edx, OFFSET prompt13
	call WriteString
	call Crlf
	call Crlf

	mov edx, OFFSET prompt6
	call WriteString
	call Crlf
	call Crlf

	ret
StackToArray ENDP

StackReverse PROC
	mov edx, OFFSET prompt8
	call WriteString
	mov edx, OFFSET space
	call WriteString
	
	mov ecx, aSize
	mov esi, 0

	d1:
		mov eax, array[esi]
		add esi, 4
		call WriteDec
		mov edx, OFFSET space
		CALL WriteString
	loop d1

	mov edx, OFFSET prompt14
	call WriteString
	call Crlf
	call Crlf

	mov edx, OFFSET prompt7
	call WriteString
	call Crlf
	call Crlf

	mov ecx, aSize
	mov eax, 0
	mov esi, 0
	
	L1:
		mov eax, array[esi]
		push eax
		add esi, 4
	loop L1
	
	mov ecx, aSize
	mov esi, 0

	L2:
		pop eax
		mov array[esi], eax
		add esi, 4
	loop L2
	
	mov ecx, aSize
	mov esi, 0

	mov edx, OFFSET prompt8
	call WriteString
	mov edx, OFFSET space
	call WriteString
	
	d2:
		mov eax, array[esi]
		add esi, 4
		call WriteDec
		mov edx, OFFSET space
		CALL WriteString
	loop d2

	mov edx, OFFSET prompt15
	call WriteString
	call Crlf
	call Crlf

	mov edx, OFFSET prompt6
	call WriteString
	call Crlf
	call Crlf

	ret
StackReverse ENDP

main PROC
	beginwhile:
		; Display prompt for user input and get user input for menu items
		mov edx, OFFSET prompt0
		call WriteString
		call Crlf
		call Crlf
		mov edx, OFFSET prompt1
		call WriteString
		call ReadInt
		mov choice, eax

		; Check user input for exit condition
		cmp choice, -1
		jz endwhile		
	
		; PUSH user input to stack and compare to menu items
		pushad
		call Crlf
		
		; Create Array
		cmp choice, 0
		jz createArray
		
		; ArrayToStack
		cmp choice, 1
		jz ArrayToStack

		; StackToArray
		cmp choice, 2
		jz StackToArray

		; StackReverse
		cmp choice, 3
		jz StackReverse

		; Check user input for out of bounds parameters
		cmp choice, -2
		jle InvalidEntry
		
		cmp choice, 3
		jg InvalidEntry
		
		; POP user input from stack
		popad

		jmp beginwhile
	endwhile:
	exit

main ENDP
END main